## ðŸ”· High-Level Architecture Diagram

```mermaid
flowchart TB
    User[User / Frontend]

    subgraph ControlPlane["Directory Canister (Control Plane)"]
        DirAccounts[User Accounts & Quotas]
        DirMeta[File Metadata & Index]
        DirUploads[Upload Sessions]
        DirLinks[Shareable Links - Option A]
        DirRouting[Bucket Routing]
        DirPAPI[PAPI PaymentGuard]
    end

    subgraph DataPlane["Bucket Canisters (Data Plane)"]
        Bucket1[(Bucket A)]
        Bucket2[(Bucket B)]
        BucketPAPI[PAPI PaymentGuard]
    end

    subgraph External["External Ecosystem"]
        CyclesLedger[Cycles Ledger]
        TokenLedger[ICRC-2 Token Ledgers]
    end

    User -->|start_upload + payment| DirPAPI
    DirPAPI --> DirUploads
    User -->|get_pricing| DirPAPI
    User -->|commit_upload| DirUploads
    User -->|list_files| DirMeta

    DirRouting --> Bucket1
    DirRouting --> Bucket2

    User -->|put_chunk + payment| BucketPAPI
    BucketPAPI --> Bucket1
    User -->|get_chunk + DownloadToken| Bucket1
    User -->|resolve_share_link| DirLinks
    DirLinks --> DirMeta
    DirMeta -->|Generate DownloadToken| User

    Bucket1 -->|report_chunk| DirUploads

    DirPAPI --> CyclesLedger
    DirPAPI --> TokenLedger
    BucketPAPI -->|Attached Cycles| Bucket1
```

## ðŸ”· Payment Logic (PAPI)

Payment logic is modularised into `payments.rs` in each canister, using the **PAPI (Paid APIs)** library.

- **Directory (Control Plane)**: Enforces fees for metadata operations and manages the **Rent Model**. It tracks a user's `expires_at_ns` and `prepaid_balance`.
- **Bucket (Data Plane)**: Enforces storage fees for `put_chunk`. Now supports both **Attached Cycles** and **ICRC-2 Tokens** (ICP/ckUSDC), ensuring that bucket canisters are refueled directly by the users.

### Rent Model & Garbage Collection

The Directory canister uses a `canister_heartbeat` to periodically run a `garbage_collect` task.

- **Expiry**: When `time() > expires_at_ns + 30 days`, the user's account and all associated files are deleted.
- **Top-Up**: Users can extend their expiration by calling `top_up_balance`.

## ðŸ”· Upload Sequence Diagram (Complete Flow)

```mermaid
sequenceDiagram
    participant U as User
    participant L as Ledger (ICRC-2)
    participant D as Directory (Control)
    participant B as Bucket (Data)

    Note over U, L: 1. Payment Phase
    U->>L: icrc2_approve(Spender: Directory, Amount)
    L-->>U: Allowance Created

    Note over U, D: 2. Authorization Phase
    U->>D: start_upload(Size, PaymentInfo)
    Note right of D: Check if Account Expired
    D->>L: icrc2_transfer_from(User, Amount)
    D-->>U: upload_id

    U->>D: get_upload_tokens(upload_id, [chunk_indices])
    Note right of D: SignerMethods::IssueToken
    D-->>U: Vec<UploadToken> (Signed)

    Note over U, B: 3. Storage Phase
    loop For each chunk
        U->>B: put_chunk(token, index, bytes, cycles)
        Note right of B: Verify HMAC Signature
        B-->>U: success
        B-->>D: report_chunk_uploaded(upload_id, index)
    end

    Note over U, D: 4. Finalization
    U->>D: commit_upload(upload_id)
    D-->>U: FileMeta (Success)
```

## ðŸ”· Link Sharing (Capability-Based)

Vault Core uses a two-layer token system for secure, decentralized file access:

### Two-Layer Token Mechanism

1.  **Option A (Shareable Link)**: A 256-bit random, unguessable token stored in the `LINKS` stable map of the Directory canister. It maps to a `FileId` and has a TTL. Useful for public/semi-public sharing.
2.  **Option B (Download Capability Token)**: An HMAC-SHA256 signed structure containing `{ file_id, bucket_id, directory_id, expires_at }`. This is generated by the Directory upon resolution of an Option A link or directly for authorized ACL users.
3.  **Decentralized Verification**: The Bucket canister verifies the signature of the Option B token using a shared secret. This allows the Bucket to serve chunks without calling the Directory for every request.

### Link Resolution Sequence

```mermaid
sequenceDiagram
    participant U as Anonymous User
    participant D as Directory (Control)
    participant B as Bucket (Data)

    U->>D: resolve_share_link(token_a)
    Note right of D: Verify token_a exists & not expired
    Note right of D: Generate & Sign token_b (Capability)
    D-->>U: DownloadPlan { auth: [token_b] }

    U->>B: get_chunk(token_b, index)
    Note right of B: Verify HMAC(token_b.sig)
    B-->>U: chunk_bytes
```

## ðŸ”· Bucket Provisioning Logic (Shard Growth)

```mermaid
flowchart LR
    A[Active Bucket]
    B{Used > Soft Limit?}
    C[Mark Bucket Draining]
    D[Create New Bucket]
    E[Route New Files to New Bucket]

    A --> B
    B -- No --> A
    B -- Yes --> C --> D --> E
```

## ðŸ”· Testing Infrastructure

The system's integrity is verified via a centralized integration test suite using `PocketIC`. These tests simulate the entire sharded environment, including the inter-canister interactions between the Directory and Buckets, as well as the cycle-based billing logic.

For technical details on the test architecture, see [HACKING.md](file:///Users/antonio.ventilii/projects/vault-core/HACKING.md).
