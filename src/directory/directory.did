type Account = record { owner : principal; subaccount : opt blob };
type CallerPaysIcrc2Tokens = record { ledger : principal };
type ChunkLocation = record { chunk_index : nat32; bucket : principal };
type DirectoryError = variant {
	UploadSessionNotFound;
	PaymentFailed : text;
	Unauthorized;
	FileNotFound;
	InvalidRequest : text;
	NoWritableBuckets;
	TransferFailed : text;
	UploadIncomplete : record { expected : nat32; uploaded : nat32 };
	QuotaExceeded : record { requested : nat64; used : nat64; quota : nat64 }
};
type DownloadPlan = record {
	chunk_count : nat32;
	locations : vec ChunkLocation;
	chunk_size : nat32
};
type FileId = record { id : blob; owner : principal };
type FileMeta = record {
	status : FileStatus;
	sha256 : opt blob;
	mime : text;
	name : text;
	size_bytes : nat64;
	updated_at_ns : nat64;
	created_at_ns : nat64;
	chunk_count : nat32;
	chunk_size : nat32;
	file_id : FileId
};
type FileStatus = variant { Ready; Deleted; Pending };
type InitArgs = record { cycles_ledger : principal };
type PatronPaysIcrc2Tokens = record { ledger : principal; patron : Account };
type PaymentType = variant {
	PatronPaysIcrc2Tokens : PatronPaysIcrc2Tokens;
	AttachedCycles;
	CallerPaysIcrc2Cycles;
	CallerPaysIcrc2Tokens : CallerPaysIcrc2Tokens;
	PatronPaysIcrc2Cycles : Account
};
type Result = variant { Ok; Err : DirectoryError };
type Result_1 = variant { Ok : FileMeta; Err : DirectoryError };
type Result_2 = variant { Ok : DownloadPlan; Err : DirectoryError };
type Result_3 = variant { Ok : vec UploadToken; Err : DirectoryError };
type Result_4 = variant { Ok : UploadSession; Err : DirectoryError };
type UploadSession = record {
	expected_chunk_count : nat32;
	mime : text;
	name : text;
	upload_id : blob;
	expected_size_bytes : nat64;
	chunk_size : nat32;
	uploaded_chunks : vec nat32;
	expires_at_ns : nat64;
	file_id : FileId
};
type UploadToken = record {
	sig : blob;
	bucket_id : principal;
	upload_id : blob;
	directory_id : principal;
	expires_at : nat64;
	allowed_chunks : vec nat32;
	file_id : FileId
};
type UserState = record { used_bytes : nat64; quota_bytes : nat64 };
service : (InitArgs) -> {
	abort_upload : (blob) -> (Result);
	commit_upload : (blob) -> (Result_1);
	delete_file : (FileId) -> (Result);
	get_download_plan : (FileId) -> (Result_2) query;
	get_file_meta : (FileId) -> (Result_1) query;
	get_pricing : () -> (text) query;
	get_upload_tokens : (blob, vec nat32) -> (Result_3);
	get_usage : (opt principal) -> (UserState) query;
	list_files : () -> (vec FileMeta) query;
	provision_bucket : (principal) -> (Result);
	report_chunk_uploaded : (blob, nat32) -> (Result);
	start_upload : (text, text, nat64, opt PaymentType) -> (Result_4)
}
